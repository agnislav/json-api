"use strict";

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { "default": obj }; };

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

var ResponseContext = _interopRequire(require("./types/Context/ResponseContext"));

var Document = _interopRequire(require("./types/Document"));

var requestValidators = _interopRequireWildcard(require("./steps/http/validate-request"));

var negotiateContentType = _interopRequire(require("./steps/http/negotiate-content-type"));

var labelToIds = _interopRequire(require("./steps/pre-query/label-to-ids"));

var parseRequestResources = _interopRequire(require("./steps/pre-query/parse-resources"));

var applyTransform = _interopRequire(require("./steps/apply-transform"));

var doFind = _interopRequire(require("./steps/do-query/do-find"));

var doCreate = _interopRequire(require("./steps/do-query/do-create"));

var doUpdate = _interopRequire(require("./steps/do-query/do-update"));

var doDelete = _interopRequire(require("./steps/do-query/do-delete"));

/**
 *
 */

module.exports = function (registry) {
  var supportedExt = ["bulk"];
  /**
   *
   * @param {RequestContext} requestContext The request context that will be
   *    used by the pipeline to generate the ResponseContext for the request.
   * @param {Object} frameworkReq This should be the request object generated by
   *    the framework that you're using. But, really, it can be absolutely
   *    anything, as this pipeline won't use it for anything except passing it
   *    to user-provided functions that it calls (like transforms and id mappers).
   * @param {Object} frameworkRes Theoretically, the response objcet generated
   *     by your http framework but, like with frameworkReq, it can be anything.
   */
  return function (requestContext, frameworkReq, frameworkRes) {
    var responseContext = new ResponseContext();

    // Now, kick off the chain for generating the response.
    // We'll validate and parse the body if one is present and, if one isn't,
    // we'll throw an error if one was supposed to be (or vice-versa).
    return requestValidators.checkBodyExistence(requestContext).then(function () {
      if (requestContext.hasBody) {
        return requestValidators.checkBodyIsValidJSONAPI(requestContext.body).then(function () {
          return requestValidators.checkContentType(requestContext, supportedExt).then(function () {
            return parseRequestResources(requestContext).then(function () {
              requestContext.primary = applyTransform(requestContext.primary, "beforeSave", registry, frameworkReq, frameworkRes);
            });
          });
        });
      }
    })

    // Map label to idOrIds, if applicable.
    .then(function () {
      if (requestContext.idOrIds && requestContext.allowLabel) {
        return labelToIds(registry, frameworkReq, requestContext, responseContext);
      }
    })

    // Actually fulfill the request!
    .then(function () {
      // If we've already populated the primary resources, which is possible
      // because the label may have mapped to no id(s), we don't need to query.
      if (typeof responseContext.primary === "undefined") {
        switch (requestContext.method) {
          case "get":
            return doFind(requestContext, responseContext, registry);

          case "post":
            return doCreate(requestContext, responseContext, registry);

          case "patch":
            return doUpdate(requestContext, responseContext, registry);

          case "delete":
            return doDelete(requestContext, responseContext, registry);
        }
      }
    })

    // Log any errors
    ["catch"](function (err) {
      console.log(err, err.stack);
      responseContext.errors = responseContext.errors.concat(err);
    })

    // Negotiate the content type
    .then(function () {
      var accept = requestContext.accepts;
      var usedExt = responseContext.ext;
      return negotiateContentType(accept, usedExt, supportedExt).then(function (it) {
        responseContext.contentType = it;
      });
    })

    // apply transforms pre-send
    .then(function () {
      responseContext.primary = applyTransform(responseContext.primary, "beforeRender", registry, frameworkReq, frameworkRes);
      responseContext.included = applyTransform(responseContext.included, "beforeRender", registry, frameworkReq, frameworkRes);
    }).then(function () {
      if (responseContext.errors.length) {
        responseContext.status = pickStatus(responseContext.errors.map(function (v) {
          return Number(v.status);
        }));
        responseContext.body = new Document(responseContext.errors).get();
      } else {
        responseContext.body = new Document(responseContext.primary, responseContext.included).get();
      }
      return responseContext;
    });
  };
};

/**
 * Returns the status code that best represents a set of error statuses.
 */
function pickStatus(errStatuses) {
  return errStatuses[0];
}