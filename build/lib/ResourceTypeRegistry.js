// Generated by LiveScript 1.2.0
(function(){
  var Q, mongoose, Document, ResourceTypeRegistry;
  Q = require('q');
  mongoose = require('mongoose');
  Document = require('./types/Document');
  /**
   * To fulfill a JSON API request, you often need to know about all the 
   * resources in the system--not just the primary resource associated with
   * the type being requested. For example, if the request is for a User, 
   * you might need to include related Projects, so the code handling the users
   * request needs access to the Project resource's beforeSave and afterQuery 
   * methods. Similarly, it would need access to url templates that point at 
   * relationships on the Project resources, to return those templates with the
   * included Projects. Etc. So we handle this by introducing a ResourceTypeRegistry 
   * that the BaseController can have access to. Each resource type is registered
   * by its name (the JSON api type value) and has four properties: adapter, 
   * urlTemplates, and the beforeSave and afterQuery methods.
   */
  ResourceTypeRegistry = (function(){
    ResourceTypeRegistry.displayName = 'ResourceTypeRegistry';
    var prototype = ResourceTypeRegistry.prototype, constructor = ResourceTypeRegistry;
    function ResourceTypeRegistry(){
      this._resourceTypes = {
        "errors": {}
      };
    }
    prototype.type = function(type, description){
      var this$ = this;
      if (description) {
        this._resourceTypes[type] = {};
        return ["adapter", "beforeSave", "afterQuery", "labelToIdOrIds", "urlTemplates", "defaultIncludes", "info", "parentType", "preCreate", "preUpdate"].forEach(function(it){
          if (description[it] != null) {
            return this$[it](type, description[it]);
          }
        });
      } else {
        if (this._resourceTypes[type] != null) {
          return import$({}, this._resourceTypes[type]);
        }
      }
    };
    prototype.adapter = makeGetterSetter('adapter');
    prototype.beforeSave = makeGetterSetter('beforeSave');
    prototype.afterQuery = makeGetterSetter('afterQuery');
    prototype.labelToIdOrIds = makeGetterSetter('labelToIdOrIds');
    prototype.defaultIncludes = makeGetterSetter('defaultIncludes');
    prototype.info = makeGetterSetter('info');
    prototype.parentType = makeGetterSetter('parentType');
    prototype.preCreate = makeGetterSetter('preCreate');
    prototype.preUpdate = makeGetterSetter('preUpdate');
    prototype.urlTemplates = function(type, templates){
      var type, ref$, resource, path, template;
      switch (arguments.length) {
      case 1:
        return ((ref$ = this._resourceTypes)[type] || (ref$[type] = {}))['urlTemplates'];
      case 0:
        templates = {};
        for (type in ref$ = this._resourceTypes) {
          resource = ref$[type];
          import$(templates, resource.urlTemplates || {});
        }
        return templates;
      default:
        for (path in templates) {
          template = templates[path];
          if (!deepEq$(path.split('.')[0], type, '===')) {
            throw new Error("Template paths must be scoped to this type");
          }
        }
        return ((ref$ = this._resourceTypes)[type] || (ref$[type] = {}))['urlTemplates'] = templates;
      }
    };
    prototype.urlTemplate = function(path){
      return this._resourceTypes[path.split('.')[0]]['urlTemplates'][path];
    };
    prototype.types = function(){
      return Object.keys(this._resourceTypes);
    };
    return ResourceTypeRegistry;
  }());
  module.exports = ResourceTypeRegistry;
  function makeGetterSetter(attrName){
    return function(type, optValue){
      if (!deepEq$(typeof this._resourceTypes[type], "object", '===')) {
        throw new Error("Type " + type + ' has not been registered.');
      }
      if (optValue) {
        return this._resourceTypes[type][attrName] = optValue;
      } else {
        return this._resourceTypes[type][attrName];
      }
    };
  }
  function import$(obj, src){
    var own = {}.hasOwnProperty;
    for (var key in src) if (own.call(src, key)) obj[key] = src[key];
    return obj;
  }
  function deepEq$(x, y, type){
    var toString = {}.toString, hasOwnProperty = {}.hasOwnProperty,
        has = function (obj, key) { return hasOwnProperty.call(obj, key); };
    var first = true;
    return eq(x, y, []);
    function eq(a, b, stack) {
      var className, length, size, result, alength, blength, r, key, ref, sizeB;
      if (a == null || b == null) { return a === b; }
      if (a.__placeholder__ || b.__placeholder__) { return true; }
      if (a === b) { return a !== 0 || 1 / a == 1 / b; }
      className = toString.call(a);
      if (toString.call(b) != className) { return false; }
      switch (className) {
        case '[object String]': return a == String(b);
        case '[object Number]':
          return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
        case '[object Date]':
        case '[object Boolean]':
          return +a == +b;
        case '[object RegExp]':
          return a.source == b.source &&
                 a.global == b.global &&
                 a.multiline == b.multiline &&
                 a.ignoreCase == b.ignoreCase;
      }
      if (typeof a != 'object' || typeof b != 'object') { return false; }
      length = stack.length;
      while (length--) { if (stack[length] == a) { return true; } }
      stack.push(a);
      size = 0;
      result = true;
      if (className == '[object Array]') {
        alength = a.length;
        blength = b.length;
        if (first) { 
          switch (type) {
          case '===': result = alength === blength; break;
          case '<==': result = alength <= blength; break;
          case '<<=': result = alength < blength; break;
          }
          size = alength;
          first = false;
        } else {
          result = alength === blength;
          size = alength;
        }
        if (result) {
          while (size--) {
            if (!(result = size in a == size in b && eq(a[size], b[size], stack))){ break; }
          }
        }
      } else {
        if ('constructor' in a != 'constructor' in b || a.constructor != b.constructor) {
          return false;
        }
        for (key in a) {
          if (has(a, key)) {
            size++;
            if (!(result = has(b, key) && eq(a[key], b[key], stack))) { break; }
          }
        }
        if (result) {
          sizeB = 0;
          for (key in b) {
            if (has(b, key)) { ++sizeB; }
          }
          if (first) {
            if (type === '<<=') {
              result = size < sizeB;
            } else if (type === '<==') {
              result = size <= sizeB
            } else {
              result = size === sizeB;
            }
          } else {
            first = false;
            result = size === sizeB;
          }
        }
      }
      stack.pop();
      return result;
    }
  }
}).call(this);
